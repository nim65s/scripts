#!/bin/bash

# Script de gestion de files d'attentes et de pages contenant plusieurs liens pour le même fichier chez différents hébergeurs
# Fondé sur plowshare
# Écrit par Nim65s
# Licence GNU GPL v3

# TODO : plowdown -v donne la version :)
# TODO : beaucoup plus tard : ajouter la possibilité de dire qu'une page avec plein de liens, ben faut tous les télécharger :D genre l'option --mass :D
# TODO : arreter le un sous shell ?
# TODO : le case pour MU, c'est vraiment naze
# TODO : vérifier que si y'a une page miroriii qui link vers 12000 pages miroriii, ca pose pas de pb
# TODO : commencer par vérifier que les fichiers sont présents sur le serveur, virer ceux qui ne le sont pas 
#        ( sans rien dire si y'a d'autres liens dans un multi, sinon on l'affiche et modifie le code d'erreur ),
#        puis afficher tous les noms des fichiers à télécharger suivi de tous les hébergeurs disponibles
# TODO : le destdir sera toujours celui qui a été lancé en preums
# TODO : option "série" pour les petites connections

# options : 
#       o : overpasser le verrou TODO
# codes de sortie : 
#               1 : déjà en fonctionnement => ajout des adresses dans la liste d'attente

# DEBUG : si le script a manifestement finit de télécharger mais ne s'arrête pas, c'est qu'il attend qu'il n'y ait plus de plowdown en cours. Si vous n'avez plus de téléchargement en cours, faites un "pkill plowdown"

# variables issues de plowshare v 0.9.1
# 0.9.2 sortie : ajoute les modules filefactory, humyo et data.hu
declare -a MODULES
MODULES=(rapidshare megaupload 2shared badongo mediafire 4shared zshare depositfiles storage_to uploaded_to uploading netload_in usershare sendspace x7_to hotfile divshare freakshare dl_free_fr loadfiles)
MODULE_2SHARED_REGEXP_URL="http://\(www\.\)\?2shared.com/file/"
MODULE_4SHARED_REGEXP_URL="http://\(www\.\)\?4shared\.com/file/"
MODULE_BADONGO_REGEXP_URL="http://\(www\.\)\?badongo.com/"
MODULE_DEPOSITFILES_REGEXP_URL="http://\(\w\+\.\)\?depositfiles.com/"
MODULE_DIVSHARE_REGEXP_URL="http://\(www\.\)\?divshare.com/download"
MODULE_DL_FREE_FR_REGEXP_URL="http://dl.free.fr/"
MODULE_FREAKSHARE_REGEXP_URL="^http://\(www\.\)\?freakshare\.net/files/"
MODULE_HOTFILE_REGEXP_URL="^http://\(www\.\)\?hotfile\.com/"
MODULE_LETITBIT_REGEXP_URL="http://\(www\.\)\?letitbit.net/"
MODULE_LOADFILES_REGEXP_URL="http://\(\w\+\.\)\?loadfiles\.in/"
MODULE_MEDIAFIRE_REGEXP_URL="http://\(www\.\)\?mediafire.com/"
MODULE_MEGAUPLOAD_REGEXP_URL="^http://\(www\.\)\?mega\(upload\|rotic\|porn\).com/"
MODULE_NETLOAD_IN_REGEXP_URL="^http://\(www\.\)\?netload\.in/"
MODULE_RAPIDSHARE_REGEXP_URL="http://\(\w\+\.\)\?rapidshare.com/"
MODULE_SENDSPACE_REGEXP_URL="http://\(www\.\)\?sendspace.com/file/"
MODULE_STORAGE_TO_REGEXP_URL="^http://\(www\.\)\?storage.to/get/"
MODULE_UPLOADED_TO_REGEXP_URL="^http://\(www\.\)\?\(uploaded.to\|ul\.to\)/"
MODULE_UPLOADING_REGEXP_URL="http://\(\w\+\.\)\?uploading.com/"
MODULE_USERSHARE_REGEXP_URL="http://\(www\.\)\?usershare.net/"
MODULE_X7_TO_REGEXP_URL="^http://\(www\.\)\?x7.to/"
MODULE_ZSHARE_REGEXP_URL="^http://\(www\.\)\?zshare.net/download"

miroriii_regexp_url="^http://\(www\.\)\?miroriii.com/"
OLDIFS=$IFS
IFS=$'\n'

megaupload="-a $MUUA"
NOMBRE=0
RUNNING=0
MIRORIII=0
[[ -d /tmp/dlbot ]] && RUNNING=1 && NOMBRE=$( ls /tmp/dlbot/multi | tail -n 1)

if [[ $# = 0 ]]
  then
# TODO : si running, relancer le daemon
    IFS=$OLDIFS
    exit 1
  fi

while [[ -f /tmp/dlbot/STOP ]]
  do
    echo -n .
    sleep 1
  done
echo .
mkdir -pv /tmp/dlbot/wd /tmp/dlbot/todl /tmp/dlbot/multi /tmp/dlbot/multiwd
echo "Ce fichier est un verrou servant au script dlbot de ne pas s'embrouiller dans la recherche des fichiers à télécharger.
Il est détruit avant la phase de téléchargement pour permettre de reremplir les files d'attentes.
Si une autre instance du script est lancée tant que le verrou est actif, elle patientera gentiment en remplissant la page de petits points." > /tmp/dlbot/STOP
# TODO : option pour virer ce fichier ?

dllestodl()
  {
    local MODULE_DL="$1"
    local ERROR_DL=0
    local TODL_DL=""
    cd /tmp/dlbot/todl
    while [[ $(cat $MODULE_DL | wc -l) != 0 ]]
      do
	TODL_DL="$(head -n 1 /tmp/dlbot/todl/$MODULE_DL)"
	echo -e "\n\033[1mTéléchargement de $(echo "$TODL_DL" | sed "s/-o/===>/")\n\033[0m"
    # 	    plowdown "${!MODULE_UT}" "$TODL_UT" -o $DESTDIR_UT TODO
													echo "92 -- plowdown $TODL_DL" >> $HOME/refonte.log
	plowdown $TODL_DL >> $HOME/refonte.log
	ERROR_DL=$?
	if [[ $ERROR_DL -gt 0 ]]
	  then
	    echo " !!!!!!!!! PLOWDOWN FAIL : dllestodl : $TODL_DL => $ERROR_DL !!!!!!!!!!!!! "
	    echo "$(date +'%s%N') : FAIL : dllestodl : $TODL_DL => $ERROR_DL " >> $HOME/dlbot.log
	    sed -i "/$(echo $TODL_DL | sed "s/.*[/]//g")/d" $MODULE_DL # TODO plutôt renvoyer la ligne à la fin, avec une marque de doublon, et un maxtry
	  else
	    echo "$(date +'%s%N') : SUCCESS : dllestodl : $TODL_DL => $DESTDIR_DL" >> $HOME/dlbot.log
	    sed -i "/$(echo $TODL_DL | sed "s/.*[/]//g")/d" $MODULE_DL
													echo "103 -- sed -i /$(echo $TODL_DL | sed s/.*[/]//g)/d $MODULE_DL --:-- $?" >> $HOME/refonte.log
	  fi
      done
  }

lycos()
  {
    local MODULE_LY="$1"
    local ERROR_LY=0
    local CONCURENTS_LY=""
    local LINE_LY=""
    local TODL_LY=""
    cd /tmp/dlbot/multi
    for((TRY_LY=1;TRY_LY<=$(ls /tmp/dlbot/multi | sort -g | tail -n 1);TRY_LY++))
      do
	if [[ -f $TRY_LY ]]
	  then
	    if [[ $( tail -n 1 $TRY_LY ) != nim* || "$3" = cm ]]
	      then
		while read LINE_LY
		  do
		    if [[ "$(echo $LINE_LY | cut -f 1)" = "$MODULE_LY" ]]
		      then
			echo -e "nimrun\t$MODULE_LY" >> $TRY_LY # on pourrait ajouter le PID, ca ferait plus classe... 
													echo "127 -- nimrun\t$MODULE_LY >> $TRY_LY" >> $HOME/refonte.log
			TODL_LY="$(echo $LINE_LY | cut -f 2)"
			echo -e "\n\033[1mTéléchargement de $(echo "$TODL_LY" | sed "s/-o/===>/")\n\033[0m"
													echo "130 -- plowdown $TODL_LY" >> $HOME/refonte.log
			plowdown $TODL_LY
			ERROR_LY=$?
			if [[ $ERROR_LY -gt 0 ]]
			  then
			    echo " !!!!!!!!! PLOWDOWN erreur # $ERROR_LY !!!!!!!!!!!!! "
			    sed -i "s/nimrun\t$MODULE_LY/nimfail\t$LINE_LY\t$ERROR_LY/" $TRY_LY # TODO le $LINE, dans sed, là, j'y crois pas trop...
			    echo "FAIL : lycos : $LINE_LY => $ERROR_LY " >> $HOME/dlbot.log
			  else
			    echo "SUCCESS : lycos : $(echo "$TODL_LY" | sed "s/-o/=>/") " >> $HOME/dlbot.log
			    for CONCURENTS_LY in "$( grep nimrun $TRY_LY | cut -f 2 )"
			      do
				echo -e "\033[5;31mle concurent $CONCURENTS_LY sur le fichier $TRY_LY s'est fait prendre de vitesse par $MODULE_LY\033[0m"
													echo "143 -- le concurent $CONCURENTS_LY sur le fichier $TRY_LY s'est fait prendre de vitesse par $MODULE_LY" >> $HOME/refonte.log
				kill $(ps -ef | grep $CONCURENTS_LY | grep '\(plowdown\|curl\)' | awk '{print $2 }')
													echo "145 -- kill $(ps -ef | grep $CONCURENTS_LY | grep '\(plowdown\|curl\)' | awk '{print $2 }') --:-- $?" >> $HOME/refonte.log
			      done
			    rm $TRY_LY
			  fi
			if [[ "$3" = "cm" ]]
			  then
			    [[ -f ../todl/$MODULE_LY ]] && dllestodl $MODULE_LY
			    lycos $MODULE_LY
			  fi
    # 		    sed -i "/$(echo "$LINE_LY" | sed "s/.*[/]//g")/d" /tmp/dlbot/todl/$MODULE_LY # vraiment INdispensable ? Non.
		      fi
		  done < $TRY_LY
	      fi
	  fi
      done
  }

unite_de_telechargement()
  {
    local MODULE_UT="$1"
    cd /tmp/dlbot/
    echo -e "\n\033[1m UdT : $MODULE_UT -- GO ! -- \033[0m"
    [[ -f todl/$MODULE_UT ]] && dllestodl $MODULE_UT
    if [[ $( ls /tmp/dlbot/multi | wc -l ) -gt 0 ]]
      then
	echo -e "\n\033[1m UdT : $MODULE_UT -- VA CHERCHER LYCOS ! -- \033[0m"
	lycos $MODULE_UT
      fi
    [[ -f todl/$MODULE_UT ]] && dllestodl $MODULE_UT
    if [[ $( ls /tmp/dlbot/multi | wc -l ) -gt 0 ]]
      then
	echo -e "\n\033[1m UdT : $MODULE_UT -- LYCOS ! Cherche mieux ! -- \033[0m"
	lycos $MODULE_UT cm
      fi
# TODO : un lycos qui réessaye pas ceux qu'il a foiré, et un qui réessaye une fois ceux qu'il a foiré
    if [[ -f $MODULE_UT || $( ls /tmp/dlbot/multi | wc -l ) -gt 0 ]] # TODO meme condition qu'en bas
      then
	echo -e "\n\033[1m UdT : $MODULE_UT -- GO AGAIN ! -- \033[0m"
# 	unite_de_telechargement $MODULE_UT ### TODO
      fi
    echo -e "\n\n\033[1m UdT : $MODULE_UT -- DONE ! -- \n\033[0m"
  }

if [[ -d $1 ]]
  then
    DESTDIR="$PWD/$1"
    shift
  else
    mkdir -pv $HOME/Téléchargements
    DESTDIR="$HOME/Téléchargements"
  fi
cd /tmp/dlbot/wd

while [ $1 ]
  do
    INMOD=0
    for MODULE in ${MODULES[*]}
      do
	VAR=MODULE_$(echo $MODULE | tr '[a-z]' '[A-Z]')_REGEXP_URL
	grep -q "${!VAR}" <<< "$1" && INMOD=1  && echo "$1 -o $DESTDIR" >> ../todl/$MODULE
	grep -q "${!VAR}" <<< "$1" &&									echo "205 -- $1 -o $DESTDIR >> ../todl/$MODULE" >> $HOME/refonte.log
      done
    if [[ $INMOD = 0 ]]
      then
	wget -nv $1
      fi
    shift
  done

echo -en "\033[1m Fin de la phase de recherche des pages.\033[0m\n" 


for files in $(ls)
  do
    nom=$(echo "./$files" | sed "s/[][ -._\/]*//g;s/html//").nimed
    sed "s/>/>\n/g" ./$files | grep href | sed 's/.*<a href="[ ]*//I;s/".*//' > $nom # TODO y'a d'la place à gagner ici ^^'
    sed "s/>/>\n/g" ./$files | grep src | sed 's/.*src="[ ]*//I;s/".*//' >> $nom
    INMOD=0
    while read line
      do
	for MODULE in ${MODULES[*]}
	  do
	    VAR=MODULE_$(echo $MODULE | tr '[a-z]' '[A-Z]')_REGEXP_URL
	    grep -q "${!VAR}" <<< "$line" && INMOD=1 && echo -e "$MODULE\t$line -o $DESTDIR" >> ../multiwd/$nom
	grep -q "${!VAR}" <<< "$line" &&								echo "229 -- $MODULE\t$line -o $DESTDIR >> ../multiwd/$nom" >> $HOME/refonte.log
	  done
      done < $nom
    if [[ $INMOD = 0 ]]
      then
	while read line
	  do
	    grep -q "$miroriii_regexp_url" <<< "$line" && MIRORIII=1 && echo "miroriii spoted" && wget -nv "$line"
	  done < $nom
      fi
    if [[ $INMOD = 0 && $MIRORIII = 0 ]]
      then
	echo -en "\033[5;31m Erreur ! Pas de liens vers des hébergeurs connus dans $files \033[0m\n"
	mv -v "./$files" "$DESTDIR/$files"
      else
	rm "./$files" "$nom"
      fi
  done

# TODO : c'est un gros et moche copier coller...

if [[ $MIRORIII = 1 ]]
  then
    for files in $(ls)
      do
	nom=$(echo "./$files" | sed "s/[][ -._\/]*//g;s/html//").nimed
	sed "s/>/>\n/g" ./$files | grep href | sed 's/.*<a href="[ ]*//I;s/".*//' > $nom # TODO y'a d'la place à gagner ici ^^'
	INMOD=0
	while read line
	  do
	    for MODULE in ${MODULES[*]}
	      do
		VAR=MODULE_$(echo $MODULE | tr '[a-z]' '[A-Z]')_REGEXP_URL
		grep -q "${!VAR}" <<< "$line" && INMOD=1 && echo -e "$MODULE\t$line -o $DESTDIR" >> ../multiwd/$nom
													echo "263 -- $MODULE\t$line -o $DESTDIR >> ../multiwd/$nom" >> $HOME/refonte.log
	      done
	  done < $nom
	if [[ $INMOD = 0 ]]
	  then
	    echo -en "\033[5;31m Erreur ! Pas de liens vers des hébergeurs connus dans $files alors qu'il vient de miroriii ! \033[0m\n"
	    mv -v "./$files" "$DESTDIR/$files"
	  else
	    rm "./$files" "$nom"
	  fi
      done
  fi


cd ../multiwd
for files in $(ls)
  do
    sort $files | uniq | grep -v //$ > $files.uniq
    rm $files
  done
mv * ../wd
cd ../wd
for files in $(ls)
  do
    if [[ $(cat $files | wc -l) = 1 ]]
      then
	echo "$(cut -f 2 $files)" >> ../todl/$(cut -f 1 $files)
													echo "290 -- $(cut -f 2 $files) >> ../todl/$(cut -f 1 $files)" >> $HOME/refonte.log
      else
	let "NOMBRE += 1"
	mv $files ../multi/$NOMBRE
      fi
  done
cd ../todl
for files in $(ls)
  do
    sort $files | uniq > $files.uniq
    mv $files.uniq $files
  done
# cd ../multi
# /usr/share/fslint/fslint/findup -d TODO : faut l'remettre ! ou trouver mieux ! x)
# #     declare -a ORPHANS
# #     for((i=1;i<=$NOMBRE;i++))
# #       do
# # 	[[ $( ls | grep ^$i$ | wc -l ) = 0 ]] && ORPHANS=( ${ORPHANS[*]} $i )
# #       done
# #     for((i=0;i<${#ORPHANS[*]};i++))
# #       do
# # 		là, faudrait déplacer les derniers fichiers dans les trous... Mais c'est pas primordial ^^'
# #       done
# let "NOMBRE -= ${#ORPHANS[*]}"
echo -en "\033[1m Fin de la phase de recherche des liens dans les pages.\033[0m\n"

cd ..
rmdir -v wd multiwd --ignore-fail-on-non-empty
[[ $(ls /tmp/dlbot/todl | wc -l) != 0 ]] && directdl=$(cat /tmp/dlbot/todl/* | wc -l) || directdl=0
echo -e "\033[1m dlbot a trouvé $directdl fichier(s) à télécharger directement et $NOMBRE fichier(s) à télécharger en parallèle.\033[0m"
echo -e "Levage du verrou : vous pouvez à nouveau lancer une autre instance de ce script, par exemple pour ajouter d'autres choses dans les listes d'attente ;,,,;"
rm -v /tmp/dlbot/STOP
if [[ $RUNNING = 0 ]]
  then
    pkill plowdown || echo -e "\033[5;31m ATTENTION ! 'pkill plowdown' a rien voulu savoir : $?\033[0m"
    pkill curl || echo -e "\033[5;31m ATTENTION ! 'pkill curl' a rien voulu savoir : $?\033[0m"
    while [[ $(ls todl | wc -l ) -gt 0 || $(ls multi | wc -l) -gt 0 ]] # améliorable, mais c'est pas la question
      do
	for unites in $( echo "$(ls todl) $(cat multi/* | grep -v nimrun | cut -f 1)" | sort | uniq ) # améliorable, mais c'est pas la question
	    do
	      unite_de_telechargement $unites  &
	    done
	sleep 10
	wait
      done
    echo "dlbot a fini son boulot."
  else
    echo "dlbot est en cours de fonctionnement => ajout des adresses dans la liste d'attente et fin du script."
    IFS=$OLDIFS
    exit 1
  fi
cd 
for dos in "/tmp/dlbot/wd" "/tmp/dlbot/todl" "/tmp/dlbot/multi" "/tmp/dlbot/multiwd"
  do
    [[ -d $dos ]] && if [[ $(ls $dos | wc -l) = 0 ]]
      then
	rmdir -pv $dos --ignore-fail-on-non-empty
      else
	echo -e "\033[5;31m ATTENTION ! Il reste des fichiers dans $dos : \033[0m"
	ls $dos
      fi
  done
IFS=$OLDIFS
exit 0
